extras     ::= { /\s/ comment }

supertypes ::= { _expression _definition _pattern }

externals  ::= {
                 _automatic_semicolon
                 }

inline     ::= { _pattern _semicolon _definition _type_identifier _param_type }

conflicts  ::= { }

word       ::= identifier

rules:
  compilation_unit             ::= ('package' 1(package_identifier _semicolon))* $topLevelStatementSeq?
                                 | $blockStatementSeq?
  _literal                     ::= number
                                 | boolean_literal
                                 | character_literal
                                 | symbol_literal
                                 | string_literal
                                 | interpolated_string
                                 | 'null'
  topLevelStatementSeq         :=  (_top_level_statement (_semicolon _top_level_statement)* _semicolon?)
  _top_level_statement         ::= 1(import_declaration
                                 | _template_definition
                                 | package_clause
                                 | package_object)
  _template_statement          ::= import_declaration
                                 | val_definition
                                 | literal
  _template_definition         ::= _template_class_definition -> class_definition
  _block_class_definition      ::= annotation* local_modifier* $classDef
  _template_class_definition   ::= annotation* modifiers? 'case'? 'class' $classDef
  classDef                     :=  (identifier: name) (type_parameters?: type_parameters)
                                     (constructor_annotation*: constructor_annotations)
                                     (access_modifier?: access_modifier)
                                     (class_parameters*: class_parameters)
                                     $class_template_opt
  class_template_opt           :=  ('extends' _class_template | ('extends'? _template_body)?)
  constructor                  ::= _annotated_type arguments*
  _class_template              ::= early_definitions? _class_parents _template_body?
  _class_parents               ::= constructor: parent_class_name ('with' _annotated_type: inherited_trait_name)*
  early_definitions            ::= ('{' (early_definition (_semicolon early_definition)*)? '}' 'with')
  early_definition             ::= 1(val_definition)
  _template_body               ::= '\n'? '{' _self_type? _template_statement (_semicolon _template_statement)* '}'
  _self_type                   ::= (identifier (':' type)? '=>' | 'this' ':' type '=>')
    ; TypeParamClause? ConstrAnnotation* AccessModifier?
                             ;$ClassParamClauses ($ClassTemplateOpt)
  blockStatementSeq            :=  (_block_statement (_semicolon _block_statement)* _semicolon)
  _block_statement             ::= import_declaration
                                 | _local_val_definition -> val_definition
                                 | literal
  ;PatVarDef            ::= 'val' PatDef
                         ;| 'var' VarDef
  ;Def                  ::= 1(PatVarDef
                         ;| 'def' FunDef
                         ;| 'type' nl* TypeDef
                         ;| TmplDef)
  ;PatDef               ::= Pattern2 (':' Type)? '=' Expr

  package_identifier           ::= identifier ("." identifier)*
  _definition                  ::= package_clause
                                 | package_object
                                 | class_definition
                                 | import_declaration
                                 | object_definition
                                 | trait_definition
                                 | val_definition
                                 | val_declaration
                                 | var_definition
                                 | var_declaration
                                 | type_definition
                                 | function_definition
                                 | function_declaration
  package_clause               ::= 'package' (package_identifier: name) '{' ($topLevelStatementSeq?: body) '}'
  package_object               ::= 'package' 'object' _object_definition
  import_declaration           ::= 'import' (_import_expression (',' _import_expression)*)
  _import_expression           ::= ((stable_identifier | identifier): path) ('.' (wildcard | import_selectors))?
  import_selectors             ::= '{' ((identifier | renamed_identifier) (',' (identifier | renamed_identifier))*) '}'
  renamed_identifier           ::= (identifier: name) '=>' ((identifier | wildcard): alias)
  object_definition            ::= annotation* modifiers? 'case'? 'object' _object_definition
  _object_definition           ::= (identifier: name) (extends_clause?: extend) (template_body?: body)
  class_definition             ::= annotation* modifiers? 'case'? 'class' (identifier: name)
                                     (type_parameters?: type_parameters) (class_parameters*: class_parameters)
                                     (extends_clause?: extend) (template_body?: body)
  trait_definition             ::= 'trait' (identifier: name) (type_parameters?: type_parameters)
                                     (extends_clause?: extend) (template_body?: body)
  type_parameters              ::= '[' (_variant_type_parameter (',' _variant_type_parameter)*) ']'
  _variant_type_parameter      ::= annotation* (covariant_type_parameter | contravariant_type_parameter | _type_parameter)
  covariant_type_parameter     ::= '+' _type_parameter
  contravariant_type_parameter ::= '-' _type_parameter
  _type_parameter              ::= ((wildcard | identifier): name) (type_parameters?: type_parameters)
                                     (upper_bound?: bound) (lower_bound?: bound) (view_bound*?: bound) (context_bound*?: bound)
  upper_bound                  ::= '<:' (_type: type)
  lower_bound                  ::= '>:' (_type: type)
  view_bound                   ::= '<%' (_type: type)
  context_bound                ::= ':' (_type: type)
  template_body                ::= '{' _block? '}'
  annotation                   ::= >('@' (_simple_type: name) (arguments*: arguments))
  constructor_annotation       ::= '@' (_simple_type: name) (arguments: arguments)
  _local_val_definition        ::= annotation* ('implicit' -> implicit_modifier)? ('lazy' -> lazy_modifier)?
                                     'val' (_pattern: pattern) (':' (_type: type))? '=' (_expression: value)

  val_definition               ::= annotation* modifiers? 'val' (_pattern: pattern) (':' (_type: type))? '=' (_expression: value)
  val_declaration              ::= annotation* modifiers? 'val' ((identifier: name) (',' (identifier: name))*) ':' (_type: type)
  var_declaration              ::= annotation* modifiers? 'var' ((identifier: name) (',' (identifier: name))*) ':' (_type: type)
  var_definition               ::= annotation* modifiers? 'var' (_pattern: pattern) (':' (_type: type))? '=' (_expression: value)
  type_definition              ::= annotation* modifiers? 'type' (_type_identifier: name)
                                     (type_parameters?: type_parameters) '=' (_type: type)
  function_definition          ::= annotation* modifiers? 'def' (identifier: name) (type_parameters?: type_parameters)
                                     (parameters*: parameters) (':' (_type: return_type))?
                                     (('=' (_expression: body)) | (block: body))
  function_declaration         ::= annotation* modifiers? 'def' (identifier: name) (type_parameters?: type_parameters)
                                     (parameters*: parameters) (':' (_type: return_type))?
  local_modifier               ::= 1('abstract' | 'final' | 'sealed' | 'implicit' | 'lazy')
  access_modifier              ::= ('private' | 'protected') access_qualifier?
  access_qualifier             ::= '[' (identifier | 'this') ']'
  modifiers                    ::= (local_modifier | access_modifier | 'override')+
  extends_clause               ::= 'extends' (_type: type) arguments?
  class_parameters             ::= '(' 'implicit'? (class_parameter (',' class_parameter)*)? ')'
  parameters                   ::= '(' 'implicit'? (parameter (',' parameter)*)? ')'
  class_parameter              ::= annotation* ('val' | 'var')? (identifier: name) (':' (_type: type))?
                                     ('=' (_expression: default_value))?
  parameter                    ::= annotation* (identifier: name) (':' (_param_type: type))? ('=' (_expression: default_value))?
  _block                       ::= <(((_expression | _definition) (_semicolon (_expression | _definition))*) _semicolon?)
  block                        ::= '{' _block? '}'
  _type                        ::= function_type | compound_type | infix_type | _annotated_type
  _annotated_type              ::= >(_simple_type annotation*)
  _simple_type                 ::= generic_type | projected_type | stable_type_identifier | _type_identifier
  compound_type                ::= 3((_annotated_type: base) ('with' (_annotated_type: extra))+)
  infix_type                   ::= <2(((compound_type | infix_type | _annotated_type): left)
                                     ((identifier): operator)
                                     ((compound_type | infix_type | _annotated_type): right))
  stable_type_identifier       ::= (identifier | stable_identifier) '.' _type_identifier
  stable_identifier            ::= (identifier | stable_identifier) '.' identifier
  generic_type                 ::= (_simple_type: type) (type_arguments: type_arguments)
  projected_type               ::= (_simple_type: type) '#' (_type_identifier: selector)
  function_type                ::= >((parameter_types: parameter_types) '=>' (_type: return_type))
  parameter_types              ::= -1(_annotated_type
                                 | ~1('(' (_param_type (',' _param_type)*)? ')')
                                 | compound_type
                                 | infix_type)
  _param_type                  ::= _type | lazy_parameter_type | repeated_parameter_type
  lazy_parameter_type          ::= '=>' (_type: type)
  repeated_parameter_type      ::= (_type: type) '*'
  _type_identifier             ::= identifier -> type_identifier
  _pattern                     ::= identifier
                                 | capture_pattern
                                 | tuple_pattern
                                 | case_class_pattern
                                 | infix_pattern
                                 | alternative_pattern
                                 | typed_pattern
                                 | number
                                 | boolean_literal
                                 | character_literal
                                 | symbol_literal
                                 | string_literal
                                 | wildcard
  case_class_pattern           ::= ((_type_identifier | stable_type_identifier): type) '(' ((_pattern (',' _pattern)*)?: pattern) ')'
  infix_pattern                ::= <2((_pattern: left) ((identifier): operator) (_pattern: right))
  capture_pattern              ::= 1((identifier: name) '@' (_pattern: pattern))
  typed_pattern                ::= -1((_pattern: pattern) ':' (_type: type))
  alternative_pattern          ::= <-2(_pattern '|' _pattern)
  tuple_pattern                ::= '(' _pattern (',' _pattern)+ ')'
  _expression                  ::= if_expression
                                 | match_expression
                                 | try_expression
                                 | for_expression
                                 | call_expression
                                 | generic_function
                                 | assignment_expression
                                 | infix_expression
                                 | _simple_expression
  _simple_expression           ::= interpolated_string
                                 | parenthesized_expression
                                 | field_expression
                                 | instance_expression
                                 | prefix_expression
                                 | tuple_expression
                                 | case_block
                                 | block
                                 | identifier
                                 | number
                                 | boolean_literal
                                 | character_literal
                                 | symbol_literal
                                 | string_literal
  if_expression                ::= >('if' (parenthesized_expression: condition) (_expression: consequence)
                                     ('else' (_expression: alternative))?)
  match_expression             ::= (_expression: value) 'match' (case_block: body)
  try_expression               ::= >('try' (_expression: body) catch_clause? finally_clause?)
  catch_clause                 ::= >('catch' case_block)
  finally_clause               ::= >('finally' _expression)
  case_block                   ::= -1('{' '}') | ('{' case_clause+ '}')
  case_clause                  ::= <('case' (_pattern: pattern) guard? '=>' (_block?: body))
  guard                        ::= 'if' (_expression: condition)

  enumerators                  ::= <(generator (_semicolon generator)*)
  generator                    ::= <(_pattern '<-' _expression (_semicolon? guard | _semicolon _pattern '=' _expression)*)
  for_expression               ::= 3<('for' ('(' enumerators ')' | '{' enumerators _semicolon?  '}') '\n'* 'yield'? _expression)

  assignment_expression        ::= >1((_expression: left) '=' (_expression: right))
  generic_function             ::= 4((_expression: function) (type_arguments: type_arguments))
  call_expression              ::= 4((_expression: function) (arguments: arguments) ((block | case_block)?: body))
  field_expression             ::= 4((_expression: value) '.' (identifier: field))
  instance_expression          ::= 3('new' _expression)
  infix_expression             ::= <2((_simple_expression: left) ((identifier): operator) (_expression: right))
  prefix_expression            ::= 3(('+' | '-' | '!' | '~') _simple_expression)
  tuple_expression             ::= '(' _expression (',' _expression)+ ')'
  parenthesized_expression     ::= '(' _expression ')'
  type_arguments               ::= '[' (_type (',' _type)*) ']'
  arguments                    ::= '(' (_expression (',' _expression)*)? ')'
  charEscapeSeq                :=  \\[btnfr"'\\]
  hexDigit                     :=  [0-9a-fA-F]
  unicodeEscape                :=  \\u+$hexDigit$hexDigit$hexDigit$hexDigit
  escapeSeq                    :=  ($unicodeEscape|$charEscapeSeq)
  charNoBQOrNL                 :=  [\u0020-\u005f\u0061-\u007f]
  opchar                       :=  [\-!#%&*+/\\:<=>?@\u005e\u007c~]
  upper                        :=  [$upperChars]
  upperChars                   :=  \p{Lu}\p{Lt}\p{Nl}\p{Lo}\p{Lm}\$
  letter                       :=  $upperChars$lowerChars
  idrest                       :=  [$(letter)0-9]*(_$opchar+)?
  plainid                      :=  ($upper$idrest|$varidRegex|$opchar+)
  idRegex                      :=  $plainid|[`]($charNoBQOrNL|$escapeSeq)*[`]
  lowerChars1                  :=  \p{Ll}_\u00AA\u00BB\u02B0-\u02B8\u02C0-\u02C1\u02E0-\u02E4
  lowerChars2                  :=  \u037A\u1D78\u1D9B-\u1DBF\u2071\u207F\u2090-\u209C
  lowerChars3                  :=  \u2C7C-\u2C7D\uA69C-\uA69D\uA770\uA7F8-\uA7F9\uAB5C-\uAB5F
  lowerChars                   :=  $lowerChars1$lowerChars2$lowerChars3
  varidRegex                   :=  [$(lowerChars)_]$idrest
  identifier                   ::= /($opchar+|$idRegex|$varidRegex|[`]$varidRegex[`])/
  wildcard                     ::= '_'
  decimal_numeral              :=  [0-9]+
  hex_numeral                  :=  0[xX]$hexDigit+
  integer_literal              :=  /-?($decimal_numeral|$hex_numeral)[Ll]?/
  hexDigit                     :=  [0-9a-fA-F]
  fp_lit_1                     :=  $decimal_numeral[.]$decimal_numeral$exponentPart?$floatType?
  fp_lit_2                     :=  [.]$decimal_numeral$exponentPart?$floatType?
  fp_lit_3                     :=  $decimal_numeral$exponentPart?$floatType
  fp_lit_4                     :=  $decimal_numeral$exponentPart$floatType?
  floating_point_literal       :=  /-?($fp_lit_1|$fp_lit_2|$fp_lit_3|$fp_lit_4)/
  exponentPart                 :=  ([Ee][+-]?$decimal_numeral)
  floatType                    :=  [FfDd]
  number                       ::= $integer_literal | $floating_point_literal
  boolean_literal              ::= 'true' | 'false'
  character_literal            ::= /'([\u0020-\u0026\u0028-\u007f]|\\[btnfr"'\\]|\\u+[0-9a-fA-F]{4})'/
  symbol_literal               ::= @("'" [^\\'\n]+)

  _interpolation_string_prefix ::= !(($upper $idrest): interpolation_name '"') | !($varidRegex: interpolation_name '"')
  charMinusQuoteDollar         :=  [^"\$]
  interpolated_string          ::= _interpolation_string_prefix ($charMinusQuoteDollar | _escape)* '"'
                                 | _interpolation_string_prefix '""' ('"'? '"'? $charMinusQuoteDollar | _escape)* '"'? '"""'
  _escape                      ::= "$$" | "$" identifier | "$" block
  _raw_string                  ::= /"""("?"?[^"])*"*"""/
  _simple_string               ::= '"' /[^"\n]|$escapeSeq/* '"' | '""'
  unicodeEscape                :=  \\u+$hexDigit$hexDigit$hexDigit$hexDigit
  charEscapeSeq                :=  \\[btnfr"'\\]
  escapeSeq                    :=  ($unicodeEscape|$charEscapeSeq)
  string_literal               ::= _simple_string | _raw_string
  _semicolon                   ::= ';' | _automatic_semicolon
  ;comment ::= '/*' (/[^*]*\*+([^/*][^*]*\*+)*/ | comment)* '/'
  comment                      ::= @(('//' /.*/) | '/*' /[^*]*\*+([^/*][^*]*\*+)*/ '/')